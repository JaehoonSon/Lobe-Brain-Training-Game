import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const OUTPUT_DIR = path.join(__dirname, 'output');

const args = process.argv.slice(2);
const MIGRATION_FILE = args[0] ? path.resolve(process.cwd(), args[0]) : '';
const FILTER_PATTERN = args[1] || '';

if (!MIGRATION_FILE) {
  console.error('Usage: npx tsx scripts/generate-seed-sql.ts <migration_file_path> [filter_pattern]');
  process.exit(1);
}

const generateSql = () => {
  let sqlContent = '-- Seed data\n-- Generated by scripts/generate-seed-sql.ts\n\n';

  // 1. Seed Games
  const gameMetaPath = path.join(__dirname, 'game.meta.json');
  if (fs.existsSync(gameMetaPath)) {
    const games = JSON.parse(fs.readFileSync(gameMetaPath, 'utf-8'));
    console.log(`Processing ${games.length} games from game.meta.json...`);

    const gameValues = games.map((g: any) => {
      const id = g.id;
      const categoryId = g.category_id || null;
      const name = (g.name || '').replace(/'/g, "''");
      const description = g.description ? `'${g.description.replace(/'/g, "''")}'` : 'NULL';
      const instructions = g.instructions ? `'${g.instructions.replace(/'/g, "''")}'` : 'NULL';
      const iconUrl = g.icon_url ? `'${g.icon_url.replace(/'/g, "''")}'` : 'NULL';
      const bannerUrl = g.banner_url ? `'${g.banner_url.replace(/'/g, "''")}'` : 'NULL';
      const isActive = g.is_active ?? true;
      const isProOnly = g.is_pro_only ?? false;
      const recommendedRounds = g.recommended_rounds || 5;

      return `('${id}', '${categoryId}', '${name}', ${description}, ${instructions}, ${iconUrl}, ${bannerUrl}, ${isActive}, ${isProOnly}, ${recommendedRounds})`;
    }).join(',\n');

    sqlContent += `-- Games\nINSERT INTO public.games (id, category_id, name, description, instructions, icon_url, banner_url, is_active, is_pro_only, recommended_rounds)\nVALUES\n${gameValues}\nON CONFLICT (id) DO UPDATE SET\n  category_id = EXCLUDED.category_id,\n  name = EXCLUDED.name,\n  description = EXCLUDED.description,\n  instructions = EXCLUDED.instructions,\n  icon_url = EXCLUDED.icon_url,\n  banner_url = EXCLUDED.banner_url,\n  is_active = EXCLUDED.is_active,\n  is_pro_only = EXCLUDED.is_pro_only,\n  recommended_rounds = EXCLUDED.recommended_rounds;\n\n`;
  } else {
    console.warn('game.meta.json not found, skipping games seed.');
  }

  // 2. Seed Questions
  const allFiles = fs.readdirSync(OUTPUT_DIR).filter(file => file.endsWith('.json'));
  const filteredFiles = FILTER_PATTERN 
    ? allFiles.filter(file => file.includes(FILTER_PATTERN))
    : allFiles; 

  if (filteredFiles.length === 0) {
    console.log('No matching question files found in output directory.');
  } else {
    sqlContent += `-- Questions\n`;
    
    for (const file of filteredFiles) {
      const filePath = path.join(OUTPUT_DIR, file);
      const content = fs.readFileSync(filePath, 'utf-8');
      
      try {
        const questions = JSON.parse(content);
        
        if (!Array.isArray(questions)) {
          console.warn(`Skipping ${file}: content is not an array`);
          continue;
        }

        console.log(`Processing ${file} with ${questions.length} questions...`);

        if (questions.length === 0) continue;

        const values = questions.map((q: any) => {
          const id = q.id;
          const gameId = q.game_id;
          const difficulty = q.difficulty;
          const contentJson = JSON.stringify(q.content).replace(/'/g, "''");

          return `('${id}', '${gameId}', ${difficulty}, '${contentJson}')`;
        }).join(',\n');

        sqlContent += `INSERT INTO public.questions (id, game_id, difficulty, content)\nVALUES\n${values}\nON CONFLICT (id) DO UPDATE SET\n  game_id = EXCLUDED.game_id,\n  difficulty = EXCLUDED.difficulty,\n  content = EXCLUDED.content;\n\n`;

      } catch (e) {
        console.error(`Error processing ${file}:`, e);
      }
    }
  }

  // Write file
  // Ensure directory exists
  const dir = path.dirname(MIGRATION_FILE);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  
  fs.writeFileSync(MIGRATION_FILE, sqlContent);
  console.log(`Generated SQL to ${MIGRATION_FILE}`);
};

generateSql();
